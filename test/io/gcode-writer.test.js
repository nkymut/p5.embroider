const { describe, test, expect, beforeEach } = require('@jest/globals');
const { TestUtils } = require('../helpers/test-utils.js');
const { TEST_PATTERNS, TEST_COLORS } = require('../fixtures/test-data.js');

// Mock GCode Writer class based on the library source
class MockGCodeWriter {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.isUp = true;
    this.gcode = [];
    this.currentTool = 0;
    this.feedRate = 1000; // mm/min
    this.travelSpeed = 3000; // mm/min
  }

  move(x, y, z = null) {
    const targetZ = z !== null ? z : (this.isUp ? 5 : 0);
    
    // Add G-code movement command
    if (targetZ > 0 && !this.isUp) {
      // Pen up
      this.gcode.push(`G0 Z${targetZ.toFixed(3)}`);
      this.isUp = true;
    }
    
    // Move to position
    if (x !== this.x || y !== this.y) {
      const speed = this.isUp ? this.travelSpeed : this.feedRate;
      this.gcode.push(`G0 X${x.toFixed(3)} Y${y.toFixed(3)} F${speed}`);
      this.x = x;
      this.y = y;
    }
    
    if (targetZ <= 0 && this.isUp) {
      // Pen down
      this.gcode.push(`G0 Z${targetZ.toFixed(3)}`);
      this.isUp = false;
    }
    
    // Handle custom Z values even if not changing pen state
    if (z !== null && this.z !== targetZ) {
      this.gcode.push(`G0 Z${targetZ.toFixed(3)}`);
      this.isUp = targetZ > 0;
    }
    
    this.z = targetZ;
  }

  penUp() {
    if (!this.isUp) {
      this.gcode.push('G0 Z5.000');
      this.isUp = true;
      this.z = 5;
    }
  }

  penDown() {
    if (this.isUp) {
      this.gcode.push('G0 Z0.000');
      this.isUp = false;
      this.z = 0;
    }
  }

  changeColor(colorIndex) {
    this.gcode.push(`; Color change to ${colorIndex}`);
    this.gcode.push(`T${colorIndex}`);
    this.currentTool = colorIndex;
  }

  addComment(comment) {
    this.gcode.push(`; ${comment}`);
  }

  setFeedRate(rate) {
    this.feedRate = rate;
    this.gcode.push(`F${rate}`);
  }

  generateGCodeHeader(title = 'Embroidery Pattern') {
    const header = [
      '; G-code generated by p5.embroider',
      `; Pattern: ${title}`,
      `; Generated: ${new Date().toISOString()}`,
      ';',
      'G21 ; Set units to millimeters',
      'G90 ; Absolute positioning',
      'M3 ; Spindle on (pen down mode)',
      'G0 Z5.000 ; Start with pen up',
      `F${this.feedRate} ; Set default feed rate`,
      ';'
    ];
    
    return header;
  }

  generateGCodeFooter() {
    const footer = [
      ';',
      'G0 Z5.000 ; Pen up',
      'G0 X0.000 Y0.000 ; Return to origin',
      'M5 ; Spindle off',
      'M30 ; Program end',
      ';'
    ];
    
    return footer;
  }

  generateGCode(title = 'Embroidery Pattern') {
    const header = this.generateGCodeHeader(title);
    const footer = this.generateGCodeFooter();
    
    return [...header, ...this.gcode, ...footer].join('\n');
  }

  reset() {
    this.x = 0;
    this.y = 0;
    this.z = 0;
    this.isUp = true;
    this.gcode = [];
    this.currentTool = 0;
  }

  getStats() {
    const movements = this.gcode.filter(line => line.startsWith('G0') || line.startsWith('G1')).length;
    const colorChanges = this.gcode.filter(line => line.startsWith('T')).length;
    const comments = this.gcode.filter(line => line.startsWith(';')).length;
    
    return {
      totalLines: this.gcode.length,
      movements,
      colorChanges,
      comments,
      currentPosition: { x: this.x, y: this.y, z: this.z },
      penState: this.isUp ? 'up' : 'down'
    };
  }
}

describe('GCode Writer Tests', () => {
  let gcodeWriter;

  beforeEach(() => {
    gcodeWriter = new MockGCodeWriter();
    TestUtils.resetAllMocks();
  });

  describe('GCodeWriter initialization', () => {
    test('initializes with correct default values', () => {
      expect(gcodeWriter.x).toBe(0);
      expect(gcodeWriter.y).toBe(0);
      expect(gcodeWriter.z).toBe(0);
      expect(gcodeWriter.isUp).toBe(true);
      expect(gcodeWriter.gcode).toEqual([]);
      expect(gcodeWriter.currentTool).toBe(0);
      expect(gcodeWriter.feedRate).toBe(1000);
      expect(gcodeWriter.travelSpeed).toBe(3000);
    });
  });

  describe('move function', () => {
    test('generates basic movement commands', () => {
      gcodeWriter.move(10, 5);
      
      expect(gcodeWriter.x).toBe(10);
      expect(gcodeWriter.y).toBe(5);
      expect(gcodeWriter.gcode.length).toBeGreaterThan(0);
      
      const lastCommand = gcodeWriter.gcode[gcodeWriter.gcode.length - 1];
      expect(lastCommand).toContain('X10.000');
      expect(lastCommand).toContain('Y5.000');
    });

    test('handles pen up/down sequences correctly', () => {
      gcodeWriter.penDown();
      gcodeWriter.move(10, 10);
      gcodeWriter.penUp();
      gcodeWriter.move(20, 20);
      
      const stats = gcodeWriter.getStats();
      expect(stats.penState).toBe('up');
      expect(stats.currentPosition.x).toBe(20);
      expect(stats.currentPosition.y).toBe(20);
      
      // Should contain both pen down and pen up commands
      const zCommands = gcodeWriter.gcode.filter(line => line.includes('Z'));
      expect(zCommands.length).toBeGreaterThan(1);
    });

    test('optimizes movements when pen is already in correct state', () => {
      gcodeWriter.penDown(); // First change state
      gcodeWriter.penUp();   // First pen up command
      gcodeWriter.penUp();   // Second call should be optimized out
      
      const upCommands = gcodeWriter.gcode.filter(line => line.includes('Z5.000'));
      expect(upCommands.length).toBe(1);
    });

    test('respects custom Z values', () => {
      gcodeWriter.move(5, 5, 2.5);
      
      expect(gcodeWriter.z).toBe(2.5);
      // Should find a Z command with the custom value
      const hasZCommand = gcodeWriter.gcode.some(line => line.includes('Z') && line.includes('2.5'));
      expect(hasZCommand).toBe(true);
    });

    test('uses different speeds for travel vs. drawing', () => {
      gcodeWriter.penUp();
      gcodeWriter.move(10, 10); // Travel move
      gcodeWriter.penDown();
      gcodeWriter.move(20, 20); // Drawing move
      
      const travelCommand = gcodeWriter.gcode.find(line => 
        line.includes('X10.000') && line.includes('F3000')
      );
      const drawCommand = gcodeWriter.gcode.find(line => 
        line.includes('X20.000') && line.includes('F1000')
      );
      
      expect(travelCommand).toBeDefined();
      expect(drawCommand).toBeDefined();
    });
  });

  describe('pen control functions', () => {
    test('penUp sets correct state and Z position', () => {
      gcodeWriter.penDown();
      gcodeWriter.penUp();
      
      expect(gcodeWriter.isUp).toBe(true);
      expect(gcodeWriter.z).toBe(5);
      
      const upCommand = gcodeWriter.gcode[gcodeWriter.gcode.length - 1];
      expect(upCommand).toBe('G0 Z5.000');
    });

    test('penDown sets correct state and Z position', () => {
      gcodeWriter.penDown();
      
      expect(gcodeWriter.isUp).toBe(false);
      expect(gcodeWriter.z).toBe(0);
      
      const downCommand = gcodeWriter.gcode[gcodeWriter.gcode.length - 1];
      expect(downCommand).toBe('G0 Z0.000');
    });

    test('avoids redundant pen state changes', () => {
      const initialLength = gcodeWriter.gcode.length;
      gcodeWriter.penUp(); // Already up
      
      expect(gcodeWriter.gcode.length).toBe(initialLength); // No new commands
    });
  });

  describe('color change function', () => {
    test('generates color change commands', () => {
      gcodeWriter.changeColor(2);
      
      expect(gcodeWriter.currentTool).toBe(2);
      expect(gcodeWriter.gcode).toContain('T2');
      
      const commentLine = gcodeWriter.gcode.find(line => line.includes('Color change to 2'));
      expect(commentLine).toBeDefined();
    });

    test('handles multiple color changes', () => {
      gcodeWriter.changeColor(1);
      gcodeWriter.changeColor(3);
      gcodeWriter.changeColor(0);
      
      expect(gcodeWriter.currentTool).toBe(0);
      
      const stats = gcodeWriter.getStats();
      expect(stats.colorChanges).toBe(3);
    });
  });

  describe('utility functions', () => {
    test('addComment creates proper comment lines', () => {
      gcodeWriter.addComment('This is a test comment');
      gcodeWriter.addComment('Another comment');
      
      expect(gcodeWriter.gcode).toContain('; This is a test comment');
      expect(gcodeWriter.gcode).toContain('; Another comment');
    });

    test('setFeedRate updates rate and adds command', () => {
      gcodeWriter.setFeedRate(1500);
      
      expect(gcodeWriter.feedRate).toBe(1500);
      expect(gcodeWriter.gcode).toContain('F1500');
    });

    test('getStats returns accurate information', () => {
      gcodeWriter.move(10, 10);
      gcodeWriter.changeColor(1);
      gcodeWriter.addComment('Test');
      
      const stats = gcodeWriter.getStats();
      
      expect(stats.totalLines).toBe(gcodeWriter.gcode.length);
      expect(stats.movements).toBeGreaterThan(0);
      expect(stats.colorChanges).toBe(1);
      expect(stats.comments).toBeGreaterThanOrEqual(1); // May include color change comment
      expect(stats.currentPosition).toEqual({ x: 10, y: 10, z: 5 });
      expect(stats.penState).toBe('up');
    });
  });

  describe('G-code generation', () => {
    test('generateGCodeHeader creates proper header', () => {
      const header = gcodeWriter.generateGCodeHeader('Test Pattern');
      
      expect(Array.isArray(header)).toBe(true);
      expect(header.length).toBeGreaterThan(5);
      
      // Check for essential G-code commands
      expect(header.some(line => line.includes('G21'))).toBe(true); // Units
      expect(header.some(line => line.includes('G90'))).toBe(true); // Absolute positioning
      expect(header.some(line => line.includes('Test Pattern'))).toBe(true); // Title
    });

    test('generateGCodeFooter creates proper footer', () => {
      const footer = gcodeWriter.generateGCodeFooter();
      
      expect(Array.isArray(footer)).toBe(true);
      expect(footer.length).toBeGreaterThan(3);
      
      // Check for essential ending commands
      expect(footer.some(line => line.includes('M30'))).toBe(true); // Program end
      expect(footer.some(line => line.includes('G0 X0.000 Y0.000'))).toBe(true); // Return to origin
    });

    test('generateGCode creates complete valid G-code', () => {
      gcodeWriter.move(10, 10);
      gcodeWriter.penDown();
      gcodeWriter.move(20, 20);
      gcodeWriter.penUp();
      
      const gcode = gcodeWriter.generateGCode('Test Pattern');
      
      expect(typeof gcode).toBe('string');
      expect(gcode.length).toBeGreaterThan(100);
      
      // Check structure
      expect(gcode).toContain('G21'); // Header content
      expect(gcode).toContain('M30'); // Footer content
      expect(gcode).toContain('X10.000'); // Movement content
      
      // Check that lines are properly separated
      const lines = gcode.split('\n');
      expect(lines.length).toBeGreaterThan(10);
    });

    test('handles empty pattern gracefully', () => {
      const gcode = gcodeWriter.generateGCode();
      
      expect(gcode).toContain('G21');
      expect(gcode).toContain('M30');
      
      // Should still have header and footer even with no movements
      const lines = gcode.split('\n');
      expect(lines.length).toBeGreaterThan(10);
    });
  });

  describe('coordinate precision', () => {
    test('maintains three decimal places in output', () => {
      gcodeWriter.move(1.23456, 7.89012);
      
      const moveCommand = gcodeWriter.gcode.find(line => line.includes('X1.235'));
      expect(moveCommand).toBeDefined();
      expect(moveCommand).toContain('Y7.890');
    });

    test('handles negative coordinates correctly', () => {
      gcodeWriter.move(-15.5, -22.7);
      
      const moveCommand = gcodeWriter.gcode.find(line => line.includes('X-15.500'));
      expect(moveCommand).toBeDefined();
      expect(moveCommand).toContain('Y-22.700');
    });

    test('handles very small coordinates', () => {
      gcodeWriter.move(0.001, 0.002);
      
      const moveCommand = gcodeWriter.gcode.find(line => line.includes('X0.001'));
      expect(moveCommand).toBeDefined();
      expect(moveCommand).toContain('Y0.002');
    });
  });

  describe('integration with test patterns', () => {
    test('processes simple line pattern', () => {
      const pattern = TEST_PATTERNS.simpleLine;
      
      gcodeWriter.penDown();
      pattern.vertices.forEach(vertex => {
        gcodeWriter.move(vertex.x, vertex.y);
      });
      gcodeWriter.penUp();
      
      const stats = gcodeWriter.getStats();
      // Movements include pen down, vertex moves, and pen up
      expect(stats.movements).toBeGreaterThanOrEqual(pattern.vertices.length);
      expect(stats.currentPosition.x).toBe(pattern.vertices[pattern.vertices.length - 1].x);
    });

    test('processes rectangle pattern with proper pen control', () => {
      const pattern = TEST_PATTERNS.rectangle;
      
      // Move to start without drawing
      gcodeWriter.move(pattern.vertices[0].x, pattern.vertices[0].y);
      gcodeWriter.penDown();
      
      // Draw the rectangle
      for (let i = 1; i < pattern.vertices.length; i++) {
        gcodeWriter.move(pattern.vertices[i].x, pattern.vertices[i].y);
      }
      
      gcodeWriter.penUp();
      
      const gcode = gcodeWriter.generateGCode('Rectangle Test');
      
      // Should contain pen down/up commands
      expect(gcode).toContain('Z0.000'); // Pen down
      expect(gcode).toContain('Z5.000'); // Pen up
      
      // Should visit all vertices
      pattern.vertices.forEach(vertex => {
        expect(gcode).toContain(`X${vertex.x.toFixed(3)}`);
        expect(gcode).toContain(`Y${vertex.y.toFixed(3)}`);
      });
    });

    test('handles multi-color pattern', () => {
      const colors = [TEST_COLORS.red, TEST_COLORS.green, TEST_COLORS.blue];
      
      colors.forEach((color, index) => {
        gcodeWriter.changeColor(index);
        gcodeWriter.move(index * 10, index * 10);
      });
      
      const stats = gcodeWriter.getStats();
      expect(stats.colorChanges).toBe(3);
      
      const gcode = gcodeWriter.generateGCode('Multi-color Test');
      expect(gcode).toContain('T0');
      expect(gcode).toContain('T1');
      expect(gcode).toContain('T2');
    });
  });

  describe('edge cases and error handling', () => {
    test('handles very large coordinates', () => {
      gcodeWriter.move(10000, 10000);
      
      const moveCommand = gcodeWriter.gcode.find(line => line.includes('X10000.000'));
      expect(moveCommand).toBeDefined();
    });

    test('handles rapid position changes', () => {
      for (let i = 0; i < 100; i++) {
        gcodeWriter.move(i, i * 2);
      }
      
      const stats = gcodeWriter.getStats();
      expect(stats.movements).toBeGreaterThanOrEqual(99); // May vary due to optimization
      expect(stats.currentPosition.x).toBe(99);
      expect(stats.currentPosition.y).toBe(198);
    });

    test('reset function clears all state', () => {
      gcodeWriter.move(10, 10);
      gcodeWriter.changeColor(5);
      gcodeWriter.addComment('Test');
      
      gcodeWriter.reset();
      
      expect(gcodeWriter.x).toBe(0);
      expect(gcodeWriter.y).toBe(0);
      expect(gcodeWriter.z).toBe(0);
      expect(gcodeWriter.isUp).toBe(true);
      expect(gcodeWriter.gcode).toEqual([]);
      expect(gcodeWriter.currentTool).toBe(0);
    });

    test('handles same position moves efficiently', () => {
      gcodeWriter.move(5, 5);
      const initialLength = gcodeWriter.gcode.length;
      
      gcodeWriter.move(5, 5); // Same position
      
      // Should not generate redundant movement commands
      const newCommands = gcodeWriter.gcode.length - initialLength;
      expect(newCommands).toBeLessThanOrEqual(1); // Only Z movement if needed
    });
  });
});